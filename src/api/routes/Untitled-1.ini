# src/db.py
from __future__ import annotations

import os
from typing import Generator, Optional

from sqlalchemy import create_engine, MetaData, text
from sqlalchemy.orm import (
    DeclarativeBase,
    sessionmaker,
    Session,
)

# 可選：設定模組（若失敗不阻擋）
try:
    from src.config import get_settings  # type: ignore
except Exception:  # noqa
    get_settings = None  # type: ignore

# -----------------------------------------
# 命名慣例：讓 Alembic 在 rename / diff 時更穩定
# -----------------------------------------
NAMING_CONVENTION = {
    "ix": "ix_%(column_0_label)s",
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s",
}


class Base(DeclarativeBase):
    metadata = MetaData(naming_convention=NAMING_CONVENTION)


# -----------------------------------------
# 解析資料庫 URL
# -----------------------------------------
def _resolve_database_url(
    explicit: Optional[str] = None,
    prefer_test: bool = True,
) -> str:
    """
    優先序：
    1. explicit
    2. TEST_DATABASE_URL（若 prefer_test=True）
    3. DATABASE_URL
    4. 設定物件 get_settings()
    """
    if explicit:
        return explicit

    if prefer_test:
        env_test = os.getenv("TEST_DATABASE_URL")
        if env_test:
            return env_test

    env_main = os.getenv("DATABASE_URL")
    if env_main:
        return env_main

    if get_settings:
        try:
            settings = get_settings()
            if getattr(settings, "TEST_DATABASE_URL", None) and prefer_test:
                return settings.TEST_DATABASE_URL  # type: ignore
            if getattr(settings, "DATABASE_URL", None):
                return settings.DATABASE_URL  # type: ignore
        except Exception:
            pass

    raise RuntimeError("無法解析資料庫 URL，請設定 TEST_DATABASE_URL 或 DATABASE_URL")


# -----------------------------------------
# Engine / Session 管理（惰性 + 可重置）
# -----------------------------------------
_ENGINE = None
_SessionFactory: Optional[sessionmaker] = None


def get_engine(
    url: Optional[str] = None,
    *,
    echo: bool = False,
    future: bool = True,
    pool_pre_ping: bool = True,
    pool_size: int | None = None,
    max_overflow: int | None = None,
):
    """
    惰性建立 Engine，若傳入新的 url 與既有不同會重建。
    pool_size / max_overflow 僅在非 SQLite 時適用。
    """
    global _ENGINE
    if _ENGINE is not None and url is not None:
        current_url = str(_ENGINE.url)
        if current_url != url:
            _ENGINE.dispose()
            _ENGINE = None

    if _ENGINE is None:
        resolved = _resolve_database_url(url)
        connect_args: dict = {}
        if resolved.startswith("sqlite"):
            # 多執行緒 FastAPI + SQLite（測試/開發）
            connect_args["check_same_thread"] = False

        create_kwargs: dict = {
            "echo": echo,
            "future": future,
            "pool_pre_ping": pool_pre_ping,
        }
        if not resolved.startswith("sqlite"):
            if pool_size is not None:
                create_kwargs["pool_size"] = pool_size
            if max_overflow is not None:
                create_kwargs["max_overflow"] = max_overflow

        _ENGINE = create_engine(resolved, connect_args=connect_args, **create_kwargs)
    return _ENGINE


def get_sessionmaker(
    url: Optional[str] = None,
    *,
    expire_on_commit: bool = False,
    autoflush: bool = True,
) -> sessionmaker:
    """
    回傳（或建立）全域 sessionmaker。
    若有新 URL 需重建，會比較 bind 是否同一個 engine。
    """
    global _SessionFactory
    if _SessionFactory is not None and url is not None:
        engine = get_engine(url)
        if _SessionFactory.kw.get("bind") is not engine:  # type: ignore
            _SessionFactory = None

    if _SessionFactory is None:
        engine = get_engine(url)
        _SessionFactory = sessionmaker(
            bind=engine,
            class_=Session,
            expire_on_commit=expire_on_commit,
            autoflush=autoflush,
            future=True,
        )
    return _SessionFactory


# 預設供其他模組匯入
SessionLocal = get_sessionmaker()


# -----------------------------------------
# FastAPI 依賴
# -----------------------------------------
def get_db() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# -----------------------------------------
# 測試專用：重置
# -----------------------------------------
def reset_engine_for_test(url: str):
    """
    測試 fixture 可呼叫：
        reset_engine_for_test(TEST_DATABASE_URL)
    確保每個測試 session 獨立（若需要）。
    """
    global _ENGINE, _SessionFactory, SessionLocal
    if _ENGINE is not None:
        try:
            _ENGINE.dispose()
        except Exception:
            pass
    _ENGINE = None
    _SessionFactory = None
    SessionLocal = get_sessionmaker(url)  # type: ignore


# -----------------------------------------
# 啟動檢查 / 關閉釋放
# -----------------------------------------
def test_connection() -> None:
    engine = get_engine()
    with engine.connect() as conn:
        conn.execute(text("SELECT 1"))

def dispose_engine_on_shutdown():
    global _ENGINE
    if _ENGINE is not None:
        try:
            _ENGINE.dispose()
        finally:
            _ENGINE = None


# -----------------------------------------
# 可選：create_all / drop_all（與 Alembic 併用時建議不啟動）
# -----------------------------------------
"""
def create_all(url: Optional[str] = None):
    engine = get_engine(url)
    Base.metadata.create_all(engine)

def drop_all(url: Optional[str] = None):
    engine = get_engine(url)
    Base.metadata.drop_all(engine)
"""

# -----------------------------------------
# 直接執行檔案時：連線測試
# -----------------------------------------
if __name__ == "__main__":
    engine = get_engine()
    with engine.connect() as conn:
        print("資料庫連線成功：", conn.execute(text("SELECT 1")).scalar())