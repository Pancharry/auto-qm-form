<%!
    # 共用 helper
%>
<%
    ##########################################################################
    # Alembic 自訂模板 (TEMPLATE_VERSION 2.2)
    # 修正：正確使用 down_revision (tuple 或 str 或 None)
    ##########################################################################
    TEMPLATE_VERSION = "2.2"

    USE_TYPE_ANNOTATIONS        = True
    EMBED_GIT_HASH              = TRUE = True
    EMBED_GIT_BRANCH            = True
    EMBED_AUTHOR_INFO           = True
    GIT_HASH_LENGTH             = 12
    FALLBACK_GIT_HASH           = "unknown"
    FALLBACK_GIT_BRANCH         = "unknown-branch"
    FALLBACK_AUTHOR_NAME        = "Pancharry"
    FALLBACK_AUTHOR_EMAIL       = "cahrry.lin@hotmail.com"
    INCLUDE_GIT_IN_DOCSTRING    = True
    INCLUDE_AUTHOR_IN_DOCSTRING = True
    INCLUDE_BRANCH_IN_DOCSTRING = True
    INCLUDE_META_BLOCK          = True

    PROJECT_HEADER = """# Generated by Alembic (custom template)
# Project: auto-qm-form
# NOTE: 請勿手動調整 revision / down_revision；請使用 Alembic 指令。
# SPDX-License-Identifier: MIT
# TEMPLATE_VERSION: 2.2
"""

    import os, subprocess, typing as _t

    def _run(cmd: list[str]) -> str | None:
        try:
            return subprocess.check_output(cmd, stderr=subprocess.STDOUT).decode().strip()
        except Exception:
            return None

    def get_git_hash():
        if not EMBED_GIT_HASH:
            return "disabled"
        env_full = os.getenv("GIT_COMMIT")
        env_short = os.getenv("GIT_COMMIT_SHORT")
        if env_full:
            h = env_full
        elif env_short:
            h = env_short
        else:
            h = _run(["git", "rev-parse", "HEAD"])
            if h and GIT_HASH_LENGTH and GIT_HASH_LENGTH not in (40,):
                h = h[:GIT_HASH_LENGTH]
        if not h:
            h = FALLBACK_GIT_HASH
        if GIT_HASH_LENGTH and h not in ("disabled", FALLBACK_GIT_HASH) and len(h) > GIT_HASH_LENGTH:
            h = h[:GIT_HASH_LENGTH]
        return h

    def get_git_branch():
        if not EMBED_GIT_BRANCH:
            return "disabled"
        b = os.getenv("GIT_BRANCH")
        if not b:
            b = _run(["git", "rev-parse", "--abbrev-ref", "HEAD"])
        return b or FALLBACK_GIT_BRANCH

    def get_author_name():
        if not EMBED_AUTHOR_INFO:
            return "disabled"
        n = os.getenv("GIT_AUTHOR_NAME")
        if not n:
            n = _run(["git", "config", "user.name"])
        return n or FALLBACK_AUTHOR_NAME

    def get_author_email():
        if not EMBED_AUTHOR_INFO:
            return "disabled"
        e = os.getenv("GIT_AUTHOR_EMAIL")
        if not e:
            e = _run(["git", "config", "user.email"])
        return e or FALLBACK_AUTHOR_EMAIL

    git_hash       = get_git_hash()
    git_branch     = get_git_branch()
    author_name    = get_author_name()
    author_email   = get_author_email()

    # ---- 處理 down_revision（可能是 None / str / tuple） ----
    dr = down_revision  # Alembic 提供
    if isinstance(dr, tuple):
        down_literal = "(" + ", ".join(repr(v) for v in dr) + ",)"
        down_ann = "tuple[str, ...]"
    elif isinstance(dr, str):
        down_literal = repr(dr)
        down_ann = "str | None"
    else:
        down_literal = "None"
        down_ann = "str | None"

    # branch_labels / depends_on 原樣（可能 None / tuple / str）
    def make_literal(v):
        if v is None:
            return "None"
        if isinstance(v, tuple):
            return "(" + ", ".join(repr(x) for x in v) + ("," if len(v)==1 else ",") + ")"
        return repr(v)

    branch_literal  = make_literal(branch_labels)
    depends_literal = make_literal(depends_on)
    create_dt_str   = create_date.strftime("%Y-%m-%d %H:%M:%S")

    if USE_TYPE_ANNOTATIONS:
        revision_line      = f"revision: str = {repr(up_revision)}"
        down_line          = f"down_revision: {down_ann} = {down_literal}"
        branch_line        = f"branch_labels: tuple[str, ...] | str | None = {branch_literal}"
        depends_line       = f"depends_on: tuple[str, ...] | str | None = {depends_literal}"
        git_line           = f"git_commit: str = {repr(git_hash)}"
        branch_meta_line   = f"git_branch: str = {repr(git_branch)}"
        author_name_line   = f"author_name: str = {repr(author_name)}"
        author_email_line  = f"author_email: str = {repr(author_email)}"
    else:
        revision_line      = f"revision = {repr(up_revision)}"
        down_line          = f"down_revision = {down_literal}"
        branch_line        = f"branch_labels = {branch_literal}"
        depends_line       = f"depends_on = {depends_literal}"
        git_line           = f"git_commit = {repr(git_hash)}"
        branch_meta_line   = f"git_branch = {repr(git_branch)}"
        author_name_line   = f"author_name = {repr(author_name)}"
        author_email_line  = f"author_email = {repr(author_email)}"

    meta_pairs = [
        ("revision", up_revision),
        ("down_revision", None if down_literal == "None" else down_literal),
        ("create_utc", create_dt_str),
        ("git_commit", git_hash),
        ("git_branch", git_branch),
        ("author_name", author_name),
        ("author_email", author_email),
        ("template_version", TEMPLATE_VERSION),
        ("message", message or "no message"),
    ]
%>${PROJECT_HEADER}
"""${message or "no message"}

Revision ID: ${up_revision}
% if isinstance(down_revision, tuple):
Revises (merge of): ${", ".join(down_revision)}
% elif down_revision:
Revises: ${down_revision}
% else:
Revises: None
% endif
Create Date (UTC): ${create_dt_str}
% if INCLUDE_GIT_IN_DOCSTRING:
Git Commit (generation time): ${git_hash}
% endif
% if INCLUDE_BRANCH_IN_DOCSTRING:
Git Branch (generation time): ${git_branch}
% endif
% if INCLUDE_AUTHOR_IN_DOCSTRING:
Author: ${author_name} <${author_email}>
% endif
"""
from __future__ import annotations

from alembic import op
import sqlalchemy as sa

${revision_line}
${down_line}
${branch_line}
${depends_line}
${git_line}
${branch_meta_line}
${author_name_line}
${author_email_line}
TEMPLATE_VERSION = ${repr(TEMPLATE_VERSION)}
% if INCLUDE_META_BLOCK:
MIGRATION_META: dict[str, str | None] = {
% for k,v in meta_pairs:
    ${repr(k)}: ${repr(v)},
% endfor
}
% endif

def upgrade() -> None:
    pass

def downgrade() -> None:
    pass
